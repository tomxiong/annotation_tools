# 测试脚本逻辑说明与接口文档

## 一、复制设置逻辑测试（test_copy_logic_fix.py）

### 1. 测试目标
验证复制设置逻辑的两个关键条件：
- 下一个切片未标注过
- 当前切片的生长级别与下一个切片的CFG配置生长级别一致

### 2. 核心测试逻辑
```python
def test_copy_settings_logic():
    """测试复制设置逻辑"""
    # 1. 验证方法存在性
    - should_copy_settings() 方法检查
    - is_hole_annotated() 方法检查  
    - get_config_growth_level() 方法检查
    
    # 2. 模拟测试场景
    - 设置测试的全景图和孔位
    - 测试未标注的孔位复制逻辑
    - 测试生长级别匹配检查
```

### 3. 业务接口
- `should_copy_settings(next_hole)` - 判断是否应该复制设置
- `is_hole_annotated(hole_number)` - 检查孔位是否已标注
- `get_config_growth_level(hole_number)` - 获取CFG配置的生长级别

---

## 二、微生物类型判断测试（test_microbe_type.py）

### 1. 测试目标
验证基于文件名前缀的微生物类型自动判断功能

### 2. 测试用例
```python
test_cases = [
    ("FG10000026", "fungi"),       # FG开头 -> 真菌
    ("EB10000026", "bacteria"),    # EB开头 -> 细菌
    ("NF10000033", "bacteria"),    # NF开头 -> 细菌
    ("SE10000052", "bacteria"),    # SE开头 -> 细菌
    ("fg12345678", "fungi"),       # 小写fg -> 真菌
    ("AB12345678", "bacteria"),    # 其他前缀 -> 细菌
    ("", "bacteria"),              # 空字符串 -> 细菌
    (None, "bacteria"),            # None -> 细菌
]
```

### 3. 业务接口
- `PanoramicAnnotationGUI.determine_microbe_type_from_filename(panoramic_id)` - 静态方法，根据文件名判断微生物类型

---

## 三、性能监控功能测试（test_performance_monitoring.py）

### 1. 测试目标
验证详细计时和按钮状态监控功能

### 2. 核心测试点
```python
# 1. 性能监控状态检查
- performance_monitoring_enabled.get() 检查
- performance_stats 数据结构验证

# 2. 详细计时数据结构验证
expected_detailed_keys = [
    'button_disable_times', 'settings_collect_times', 'navigation_times',
    'ui_refresh_times', 'settings_apply_times', 'button_enable_times', 'total_copy_times'
]

# 3. 按钮状态变化监控
- button_state_changes 统计检查
- 响应时间记录验证
```

### 3. 业务接口
- `performance_monitoring_enabled` - 性能监控开关
- `performance_stats` - 性能统计数据字典
- `_record_detailed_copy_timing(key, time)` - 记录详细计时
- `show_performance_analysis()` - 显示性能分析
- `_get_performance_summary()` - 获取性能摘要

---

## 四、性能优化验证测试（test_performance_optimization.py）

### 1. 测试目标
验证性能优化效果和相关方法实现

### 2. 核心测试点
```python
# 1. 延迟配置优化检查
- delay_config 配置验证
- 优化后的延迟时间检查

# 2. 优化方法存在性验证
- _apply_interference_factors_optimized_fast() 方法
- _build_interference_factor_mapping() 方法

# 3. 性能建议测试
- 添加测试数据记录
- 获取性能摘要和建议
```

### 3. 业务接口
- `delay_config` - 延迟配置字典
- `_apply_interference_factors_optimized_fast()` - 快速干扰因素应用
- `_build_interference_factor_mapping()` - 构建干扰因素映射
- `_get_performance_summary()` - 获取性能摘要

---

## 五、同步设置应用测试（test_sync_settings.py）

### 1. 测试目标
验证生长模式和干扰因素的同步设置功能

### 2. 核心测试点
```python
# 1. 延迟配置更新验证
- delay_config 配置检查

# 2. 同步方法存在性验证
- apply_annotation_settings_sync() 方法
- _apply_interference_factors_sync() 方法

# 3. 同步设置应用测试
- 模拟生长模式设置
- 模拟干扰因素应用
- 验证同步效果
```

### 3. 业务接口
- `apply_annotation_settings_sync()` - 同步应用标注设置
- `_apply_interference_factors_sync()` - 同步应用干扰因素
- `delay_config` - 延迟配置管理

---

## 六、测试脚本集成建议

### 1. 统一测试框架
- 建议将所有测试逻辑集成到 `tests/unit/` 目录下的正式单元测试中
- 使用pytest或unittest框架进行标准化测试
- 避免根目录下的独立测试脚本

### 2. 测试数据管理
- 建立统一的测试数据文件夹
- 使用mock数据进行单元测试
- 分离集成测试和单元测试

### 3. 持续集成
- 集成到CI/CD流程中
- 自动化测试执行和报告生成
- 测试覆盖率监控

---

## 七、测试接口使用示例

### 复制设置逻辑测试
```python
from src.ui.panoramic_annotation_gui import PanoramicAnnotationGUI

gui = PanoramicAnnotationGUI(root)
# 测试复制设置逻辑
should_copy = gui.should_copy_settings(next_hole=15)
is_annotated = gui.is_hole_annotated(15)
growth_level = gui.get_config_growth_level(15)
```

### 微生物类型判断
```python
microbe_type = PanoramicAnnotationGUI.determine_microbe_type_from_filename("FG10000026")
# 返回: "fungi"
```

### 性能监控
```python
gui.performance_monitoring_enabled.set(True)
gui._record_detailed_copy_timing('total_copy_times', 2384.4)
summary = gui._get_performance_summary()
```

---

## 八、文档维护说明

本文档记录了所有测试脚本的核心逻辑和业务接口，用于：
1. 替代独立测试脚本的文档说明
2. 为后续测试框架集成提供参考
3. 维护测试相关的业务接口文档

建议定期更新此文档，确保与实际测试需求保持同步。
